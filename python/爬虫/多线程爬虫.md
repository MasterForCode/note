---
title: 多线程爬虫
tags:  python，爬虫
grammar_cjkRuby: true
---


#### 多线程爬虫
有些时候，比如下载图片，因为下载图片是一个耗时的操作。如果采用同步的方式下载，效率比较低。这时可以采用多线程方式下载图片

#### 多线程介绍
多线程是为了同步完成多项任务，通过提高资源使用效率来提高系统效率

#### threading模块介绍
threading模块是python中专门提供用来多线程编程的模块。threading模块中最常用的类是Thread。
```python
# encoding:utf-8
import threading
import time


def coding():
    for x in range(3):
        print("{0}正在编程".format(x))
        time.sleep(1)


def drawing():
    for x in range(3):
        print("{0}正在画图".format(x))
        time.sleep(1)


def single_thread():
    coding()
    drawing()


def multiple_thread():
    t1 = threading.Thread(target=coding)
    t2 = threading.Thread(target=drawing)
    t1.start()
    t2.start()


if __name__ == '__main__':
    multiple_thread()

```
查看进程中的线程数
```python
threading.enumerate()
```
查看当前线程信息
```python
threading.current_thread()
```
继承threading.Thread类，实现自定义多线程类
```python
import threading
import time


class CodingThread(threading.Thread):
    def run(self):
        for x in range(3):
            print("{0}正在编程".format(x))
            time.sleep(1)


class DrawingThread(threading.Thread):
    def run(self):
        for x in range(3):
            print("{0}正在画图".format(x))
            time.sleep(1)


def main():
    t1 = CodingThread()
    t2 = DrawingThread()
    t1.start()
    t2.start()


if __name__ == '__main__':
    main()

```
多线程共享全局变量
多线程都是在同一个进程中运行的，因此进程中的全局变量所有线程都是共享的。这就产生问题，因为线程执行的顺序是不确定的。有可能造成数据错误，如下
```python
import threading

tickets = 0


def get_ticket():
    global tickets
    for x in range(1000000):
        tickets += 1
    print('tickets:{0}'.format(tickets))


def main():
    for x in range(2):
        t = threading.Thread(target=get_ticket)
        t.start()


if __name__ == '__main__':
    main()
#tickets:1053992
#tickets:1187722

```
添加资源锁
```python
import threading

tickets = 0

gLock = threading.Lock()


def get_ticket():
    global tickets
    gLock.acquire()
    for x in range(1000000):
        tickets += 1
    gLock.release()
    print('tickets:{0}'.format(tickets))


def main():
    for x in range(2):
        t = threading.Thread(target=get_ticket)
        t.start()


if __name__ == '__main__':
    main()
#tickets:1000000
#tickets:2000000

```

### Lock版本生产这和消费者模式
生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存到一个中间的变量中。消费者再从这个中间变量中取出数据进行消费。但是因为要使用中间变量，而中间变量经常是一些全局变量，因此需要使用锁来保证数据的正确性。一下使用threading.Lock锁实现的生产者与消费者模式的一个例子
```python
import random
import threading
import time

gMoney = 1000
gLock = threading.Lock()
gTotalTimes = 10
gTimes = 0


class Producer(threading.Thread):
    def run(self) -> None:
        global gMoney, gTimes
        while True:
            money = random.randint(100, 1000)
            gLock.acquire()
            # 只能在获得锁的时候做判断，否则，会出错
            if gTimes >= gTotalTimes:
                gLock.release()
                break
            gMoney += money
            print('{0}生产了{1}元钱，剩余{2}元钱'.format(threading.current_thread(), money, gMoney))
            gTimes += 1
            gLock.release()
            time.sleep(2)


class Consumer(threading.Thread):
    def run(self) -> None:
        global gMoney
        while True:
            money = random.randint(100, 1000)
            gLock.acquire()
            if gMoney >= money:
                gMoney -= money
                print('{0}消费者消费了{1}元钱剩余{2}元钱'.format(threading.current_thread(), money, gMoney))
            # 不能在if中释放锁，当条件不满足时会一直不释放锁，造成死锁
            elif gTimes >= gTotalTimes:
                print('{0}消费者准备消费{1}元，余额不足，当前为{2}'.format(threading.current_thread(), money, gMoney))
                gLock.release()
                break

            gLock.release()
            time.sleep(2)


def main():
    for x in range(3):
        t = Consumer(name='消费者线程{0}'.format(x))
        t.start()

    for x in range(5):
        t = Producer(name='生产者线程{0}'.format(x))
        t.start()


if __name__ == '__main__':
    main()

```

